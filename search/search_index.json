{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Puzzle2","text":""},{"location":"#concept","title":"Concept","text":"<p> Puzzle2 is a simple pipeline framework designed for Python scripts. The main concept is to separate these scripts from GUI and reuse them with ease, while allowing batch processing with the same scripts.</p> <p> For Example, we have seen a lot of situations like this.</p> <p></p> <p>if we use this module.  we can do like this. and this is exactry what puzzle2 trying to do.</p> <p></p> <p>This is a sample tool uses puzzle2. I hope it helps you to understand this module.</p> <p>PzPlayblast</p>"},{"location":"concept/","title":"Concept","text":"<p>test</p>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#requirement","title":"Requirement","text":"<p>python 3.7+</p> <p></p>"},{"location":"installation/#how-to","title":"How To","text":"<p>You can clone from Github or install from pip</p> <pre><code>pip install git+https://github.com/hat27/puzzle2.git\n</code></pre>"},{"location":"installation/#required","title":"required","text":"<p>If you clone repo, we recommanded to running <code>pip install -r requirements.txt</code> or  look inside file and install by your self.</p>"},{"location":"batch/introduction/","title":"Introduction","text":"<p>PuzzleBatch is a powerful feature that is currently under development. Once we create a Puzzle configuration, we can execute it without opening any applications.</p> <p>The goal is to use the dispatcher system (like Deadline) to run any type of process via server.</p>"},{"location":"testing/dcc/","title":"DCC/Deadline tests","text":"<p>These tests are opt-in due to external dependencies.</p>"},{"location":"testing/dcc/#enabledisable","title":"Enable/disable","text":"<ul> <li>Enable only when <code>PUZZLE_RUN_DCC_TESTS</code> equals one of: <code>1</code>, <code>true</code>, <code>yes</code>, <code>on</code> (case-insensitive)</li> <li>Otherwise, tests are skipped at module import time</li> </ul>"},{"location":"testing/dcc/#matrix-control","title":"Matrix control","text":"<ul> <li>tests/support/matrix.py centralizes app/version pairs</li> <li>Override with environment variables:</li> <li><code>PUZZLE_TEST_MATRIX_JSON</code> (JSON string)<ul> <li>Example (PowerShell):</li> <li><code>$env:PUZZLE_TEST_MATRIX_JSON = '{\"mayapy\":[\"2024\"],\"houdini\":[\"20.5.654\"]}'</code></li> </ul> </li> <li><code>PUZZLE_TEST_APPS</code> (semicolon-separated <code>app:version</code>)<ul> <li>Example:</li> <li><code>$env:PUZZLE_TEST_APPS = \"mayapy:2024;houdini:20.5.654\"</code></li> </ul> </li> </ul>"},{"location":"testing/dcc/#timeouts","title":"Timeouts","text":"<ul> <li><code>PUZZLE_RESULTS_TIMEOUT</code> and <code>PUZZLE_DEADLINE_TIMEOUT</code> control polling for <code>results.json</code></li> </ul>"},{"location":"testing/dcc/#notes","title":"Notes","text":"<ul> <li>Workers must be able to access shared paths for task/data/result files</li> </ul>"},{"location":"usage/config/","title":"Config","text":""},{"location":"usage/config/#config-options","title":"config options","text":"<p>to write each task config. we use key-value below.</p> key require type description name o str name of task module o str path to task comment - str data_key_replace - dict replace key name whitch used in data data_defaults - dict default value for specific key data_override - dict override value for specific key conditions - list condition for execute task break_on_exceptions - bool stop process when error occur"},{"location":"usage/config/#data_key_replace","title":"data_key_replace","text":"<p>eplace key name whitch used in data  </p> <p>config</p> <pre><code>data_key_replace:\n    min: start_frame\n    max: end_frame\n</code></pre> <p></p> <p>in this case, <code>start_frame</code> replaced to <code>min</code> and <code>end_frame</code> replaced to <code>max</code></p> <p></p> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\nconfig = [...]\ndata = {\n    \"start_frame\": 101,\n    \"end_frame\": 200\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n</code></pre> <p></p>"},{"location":"usage/config/#data_defaults","title":"data_defaults","text":"<p>set default values.if we set default values. we don't have to add key to data.</p> <p></p> <p>config</p> <pre><code>data_defaults:\n    min: 101\n</code></pre> <p>task</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))    \n\n</code></pre> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [...]\ndata = {\n    \"main\": {\n        \"max\": 200\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n# 101 - 200\n</code></pre> <p></p>"},{"location":"usage/config/#data_override","title":"data_override","text":"<p>if data_override exists, value will override to spesific value.</p> <p></p> <p>config</p> <pre><code>data_override:\n    min: 101\n</code></pre> <p>task</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))    \n\n</code></pre> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [...]\ndata = {\n    \"main\": {\n        \"min\": 0,\n        \"max\": 200\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n&gt;&gt; 101 - 200\n# min 0 was overrided by config\n</code></pre> <p></p>"},{"location":"usage/config/#conditions","title":"conditions","text":"<p>set conditions, then task will execute when condition passed</p> <p>config</p> <pre><code>conditions:\n    - change_frame_flag: false\n</code></pre> <p>task</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))    \n\n</code></pre> <p></p> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [...]\ndata = {\n    \"main\": {\n        \"min\": 0,\n        \"max\": 200,\n        \"change_frame_flag\": False\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n</code></pre> <p>in this case, this task will skipped. usually we use this when executing tasks from GUI.  </p>"},{"location":"usage/context/","title":"Context","text":"<p>context can access from everywhere</p> name description _app_ process app name _user_name_ PUZZLE_USERNAME or USERNAME _datetime_ datetime when process start _os_ version of os _python_version_ version of python"},{"location":"usage/context/#how-to-use-update_context","title":"How to Use update_context","text":"<p>use <code>data_key_replace</code> function to add <code>context.</code> to prefix before the value name. This way, the value will be searched from context.</p> <p>config</p> <pre><code>config = [\n  \"step\": \"main\",\n  \"tasks\": [\n      {\n        \"name\": \"set frame with offset\",\n        \"module\": \"somewhere.set_frame\"\n      },\n      {\n        \"name\": \"render\",\n        \"module\": \"somewhere.render\"\n        \"comment\": \"use new value from pre task\",\n        \"data_key_replace\":\n        {\n          \"start\": \"context.new_min\",\n          \"end\": \"context.new_max\"\n        }\n      }\n  ]\n]\n\n</code></pre> <p>set_frame.py</p> <pre><code>def main(event):\n    data = event[\"data\"]\n    update_context = {}\n\n    cmds.playbackOptions(min=data[\"min\"] - data[\"offset\"])\n    cmds.playbackOptions(max=data[\"max\"] + data[\"offset\"])\n\n    update_context[\"new_min\"] = data[\"min\"] - data[\"offset]\n    update_context[\"new_max\"] = data[\"max\"] + data[\"offset]\n\n    return {\"return_code\": 0, \"update_context\": update_context}\n</code></pre> <p>render.py</p> <pre><code>def main(event={}):\n    data = event.get(\"data\")\n    print(\"{} - {}\".format(data[\"start]))\n    render_file(data[\"start\"], data[\"end\"])\n    return {\"return_code\": 0}\n\n&gt;&gt; 201 - 300\n</code></pre>"},{"location":"usage/deadline/","title":"Deadline Integration","text":"<p>This page explains how to submit Puzzle2 tasks to Deadline.</p>"},{"location":"usage/deadline/#plugin-info-keys","title":"Plugin Info keys","text":"<ul> <li>App, Version: Target DCC</li> <li>ModulePath: Directory where <code>tasks.*</code> modules live (e.g., tests_data)</li> <li>SysPath: Extra entry added to <code>sys.path</code> on the Worker</li> <li>TaskPath, DataPath: JSON files describing steps and data</li> <li>ResultPath: Shared path for <code>results.json</code></li> </ul>"},{"location":"usage/deadline/#client-api","title":"Client API","text":"<pre><code>from puzzle2.plugins.deadline import client\n\nres = client.submit(\n    app=\"mayapy\",\n    job_name=\"Puzzle2 Example\",\n    version=\"2024\",\n    module_path=r\"C:\\\\path\\\\to\\\\tests_data\",\n    sys_path=r\"C:\\\\path\\\\to\\\\tests\",\n    task_path=r\"C:\\\\tmp\\\\task_set.json\",\n    data_path=r\"C:\\\\tmp\\\\data.json\",\n    result_path=r\"C:\\\\tmp\\\\results.json\",\n)\nprint(res.completed.stdout)\n</code></pre>"},{"location":"usage/deadline/#deadlinecommand-resolution","title":"deadlinecommand resolution","text":"<ul> <li>Uses DEADLINE_COMMAND, PATH, or standard install paths (Windows) to locate <code>deadlinecommand</code>.</li> </ul>"},{"location":"usage/deadline/#timeouts","title":"Timeouts","text":"<ul> <li>Workers write <code>results.json</code>. Use <code>PUZZLE_DEADLINE_TIMEOUT</code> to control how long to wait when testing.</li> </ul>"},{"location":"usage/logging/","title":"Logging (PzLog)","text":"<p>Puzzle2 uses a scoped logger that avoids process-wide logging side effects and supports custom levels.</p>"},{"location":"usage/logging/#highlights","title":"Highlights","text":"<ul> <li>Scoped logger per <code>name</code> (propagate=False)</li> <li>Custom levels: SUCCESS, RESULT, ALERT, FLAG, NOTICE</li> <li>Template fallback: YAML if available, otherwise JSON template</li> <li>Handler-level overrides via constructor kwargs (e.g., <code>stream_level</code>, <code>file_level</code>)</li> <li><code>Details</code> API to accumulate structured results per step</li> </ul>"},{"location":"usage/logging/#example","title":"Example","text":"<pre><code>from puzzle2.PzLog import PzLog\n\nlog = PzLog(\"demo\", new=True, logger_level=\"INFO\")\nlog.success(\"All good\")\nlog.result(\"Export done\")\nprint(log.logger.handlers)\n</code></pre>"},{"location":"usage/logging/#details-api","title":"Details API","text":"<ul> <li>set_name(name) -&gt; index, scoped name</li> <li>set_header(return_code, text)</li> <li>add_detail(text)</li> <li>set_data_location(path), set_data_required(obj), set_execution_time(sec)</li> <li>get_return_codes() -&gt; [0, ...]</li> <li>get_all() -&gt; list of structured dicts</li> </ul>"},{"location":"usage/pipeline/","title":"Pipeline (Nested execution)","text":"<p>You can nest DCC invocations with a <code>pipe</code> section inside steps.</p>"},{"location":"usage/pipeline/#example","title":"Example","text":"<pre><code>from puzzle2.Puzzle import Puzzle\n\np = Puzzle(\"pipeTest\", new=True)\n\nsteps = [\n  {\"step\": \"pre\", \"tasks\": [{\"module\": \"tasks.win.open_file\"}]},\n  {\"step\": \"main\", \"tasks\": [{\"module\": \"tasks.win.export_file\"}]},\n  {\"step\": \"pipe\",\n   \"pipe\": {\"app\": \"mayapy\", \"version\": \"2024\"},\n   \"sys_path\": r\"C:\\\\path\\\\to\\\\tests_data\",\n   \"tasks\": [\n     {\"step\": \"pipe.pre\",\n      \"tasks\": [\n        {\"module\": \"tasks.win.open_file\",\n         \"data_key_replace\": {\"open_path\": \"context.OpenFile.update_context_test\"}}\n      ]}\n   ]},\n]\n\ndata = {\n  \"pre\": {\"open_path\": \"somewhere\"},\n  \"common\": {\"A\": 123},\n  \"main\": [{\"name\": \"nameA\"}],\n  \"pipe.pre\": {\"open_path\": \"A\"},\n}\n\np.play(steps, data)\n</code></pre>"},{"location":"usage/response/","title":"Response","text":"<p>return value will be <code>dict</code> or <code>None</code></p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    new_min = data[\"min\"] * 2\n    new_max = data[\"max] * 2\n    cmds.playbackOptions(min=new_min, max=new_max)\n    print(\"{} - {}\".format(new_min, new_max))\n\n    update_context = {\"min\": new_min, \"max\": new_max}\n    return {\"return_code\": 0, \"update_context\": update_context}\n</code></pre> key default type description return_code 0 int result for task process update_context {} dict update context break_on_conditions False bool if True, stop all process except closure step"},{"location":"usage/response/#return-code","title":"return code","text":"id results description 0 Success 1 Error 2 skipped 4 Import Error task was not found in sys.path 5 Key Error required key was not exists(optional)"},{"location":"usage/response/#update-context","title":"update context","text":"<p>add value to context</p>"},{"location":"usage/response/#sample-of-break-on-conditions","title":"sample of break on conditions","text":"<p>when start frame is lower then 0, stop the other tasks</p> <pre><code>def main(event):\n    if cmds.playbackOptions(min=True, q=True) &lt; 0:\n        return {\"return_code\": 0, \"break_on_conditions\": True}\n    return {\"return_code\": 0}\n</code></pre>"},{"location":"usage/rule/","title":"Rule","text":"<p>We need to follow at least two rules in order to use this module.</p> <ol> <li>execute function name must be <code>main</code></li> <li>designing configurations</li> </ol> <p></p> <p>Here is an image of the process.</p> <p>Pick tasks and put them in order.</p> <p></p> <p>task will be imported so we need to add sys.path.</p> <p>root \u00a0\u00a0\u00a0\u00a0L somewhere \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L init.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task1.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task2.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task3.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task4.py  </p> <pre><code># -*-coding: utf8-*-\nimport sys\nroot = \"somewhere\"\nsys.path.append(root)\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [\n  \"step\": \"main\",\n  \"tasks\": [\n    {\"name\": \"task1\",\n     \"module\": \"somewhere.task1\"},\n    {\"name\": \"task2\",\n     \"module\": \"somewhere.task2\"},\n    {\"name\": \"task3\",\n     \"module\": \"somewhere.task3\"},\n    {\"name\": \"task4\",\n     \"module\": \"somewhere.task4\"},\n  ]\n]\n\npuzzle = Puzzle()\npuzzle.play(config)\n</code></pre>"},{"location":"usage/run_process/","title":"Run Process","text":"<p>This page explains how to launch DCC applications in batch/headless mode via <code>puzzle2.run_process</code> and where artifacts are written.</p>"},{"location":"usage/run_process/#what-it-does","title":"What it does","text":"<ul> <li>Resolves the executable/arguments for the requested app/version</li> <li>Creates an isolated job directory per run</li> <li>Writes artifacts like <code>results.json</code> and <code>std.txt</code></li> <li>Optionally generates a <code>.bat</code> instead of executing immediately</li> </ul>"},{"location":"usage/run_process/#key-parameters","title":"Key parameters","text":"<ul> <li>module_directory_path: Where your tasks (e.g., <code>tasks.win.*</code>) live</li> <li>task_set_path or task_set: Task set file (.yml/.json) or in-memory data</li> <li>data_path or data_set: Data file (.json) or in-memory data</li> <li>result_path: Where to write results.json (default inside job_directory)</li> <li>version: DCC version like <code>2024</code></li> <li>close_app: Whether to close the app after processing</li> <li>execute_now: If false, generate a <code>.bat</code> and return</li> <li>bat_file: Path to write the <code>.bat</code> file when <code>execute_now</code> is false</li> </ul>"},{"location":"usage/run_process/#minimal-example-maya-2024","title":"Minimal example (Maya 2024)","text":"<pre><code>from puzzle2.run_process import run_process\n\ncmd = {\n    \"module_directory_path\": r\"C:\\\\path\\\\to\\\\tests_data\",\n    \"task_set_path\": r\"C:\\\\path\\\\to\\\\task_set.yml\",\n    \"data_path\": r\"C:\\\\path\\\\to\\\\data.json\",\n    \"result_path\": r\"C:\\\\tmp\\\\results.json\",\n    \"execute_now\": False,\n    \"bat_file\": r\"C:\\\\tmp\\\\puzzle2.bat\",\n    \"close_app\": True,\n    \"version\": \"2024\",\n}\n\napp = \"maya\"\ncommand, job_dir = run_process(app, **cmd)\nprint(command, job_dir)\n</code></pre>"},{"location":"usage/task/","title":"Task","text":"<p>We refer to each script as a <code>task</code>.</p> <p>we write before, task rule is use execute function name <code>main</code>.</p> <pre><code>def main():\n    print(\"hello puzzle2\")\n</code></pre> <p>this is the most easiest task. </p>"},{"location":"usage/task/#data","title":"data","text":"<p>for example, this task works to change scene to 101-200</p> <p></p> <p>change_frame.py</p> <pre><code>def main(event={}):\n    cmds.playbackOptions(min=101, max=200)\n    print(\"{} - {}\".format(101, 200))\n</code></pre> <p>In this scenario, we cannot reuse this task for other situations.  Therefore, we will need to give the minimum and maximum values from external data sources and make changes accordingly.</p> <p></p> <p>change_frame.py</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))\n</code></pre> <p>this looks more better.</p> <p></p> <p>script.py </p> <p>and then, this is usage for change_frame.py in puzzle process. CAUTION: we have to set data to same name as step name  </p> <pre><code># -*-coding: utf8-*-\nimport sys\nsys.path.append(root)\n\nfrom puzzle2.Puzzle import Puzzle\n\n# add to order config\nconfig = [\n  \"step\": \"main\",\n  \"tasks\": [\n    {\"name\": \"change_frame\",\n     \"module\": \"somewhere.change_frame\"}\n  ]\n]\n\n# set data to main step\ndata = {\n    \"main\": {\n        \"min\": 101, \n        \"max\": 200\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n# 101 - 200\n</code></pre>"},{"location":"usage/tips/","title":"Tips","text":""},{"location":"usage/tips/#use-yml-file","title":"use yml file","text":"<p>we usually use .yml file to write config. that will much easier to write it.</p> <p>yml file</p> <pre><code>info: {}\ndata:\n  some_tasks: \n    - step: pre\n      tasks:\n        - name: task1\n          module: somewhere.set_frame\n\n        - name: render\n          module: somewhere.render\n          comment: use new value from pre task\n          data_key_replace:\n            start: context.new_min\n            end: context.new_max\n\n</code></pre> <pre><code>info, config = pz_config.read(yml_path)\ndata = {}\n\npuzzle = Puzzle()\npuzzle.play(config[\"some_tasks\"], data)\n</code></pre>"},{"location":"usage/tips/#is-loop","title":"is loop?","text":"<p>In Puzzle system, whether tasks go through a loop or not depends on the data type. If the data type is a list, it will go through a loop. If the data type is a dictionary, it will only go through once.  </p> <p>A step refers to a sequential stage in your pipeline. It is simply a name you give to indicate what the tasks under that stage represent or achieve.</p> <p></p> <p>Looking at an example can help us understand better.</p> <p>config</p> <pre><code>  export_scene_tasks: \n    - step: pre\n      tasks:\n        - name: open file\n          module: somewhere.open_file\n\n        - name: export camera\n          module: somewhere.export_camera\n          conditions:\n            asset_type: camera\n\n    - step: main\n      comment: add export file info to context.\n      tasks:\n        - name: export ch assets\n          comment: append info to context\n          module: somewhere.export_ch\n          data_key_replace:\n            export_path: local_export_path\n\n          conditions:\n            asset_type: ch\n\n        - name: export prop assets\n          comment: append info to context\n          module: somewhere.export_prop\n          data_key_replace:\n            export_path: local_export_path          \n\n          conditions:\n            asset_type: prop\n\n        - name: export bg assets\n          comment: append info to context\n          module: somewhere.export_bg\n          data_key_replace:\n            export_path: local_export_path\n\n          conditions:\n            asset_type: bg\n\n        - name: copy to server\n          comment: copy export path to server\n          module: somewhere.copy_to\n          data_key_replace:\n            src_path: local_export_path\n            dst_path: server_export_path\n\n    - step: post\n      tasks:\n        - name: integrations to shotgrid\n          module: somewhere.send_to_sg\n          data_key_replace:\n            export_files: context.export_files\n</code></pre> <p>data</p> <pre><code>data = {\n    \"pre\": {\n        \"camera_name\": \"cam1\",\n        \"file\": \"xxxxx.ma\"\n    },\n    \"main\": [\n        {\"name\": \"charaA\", \"asset_type\": \"ch\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"},\n        {\"name\": \"charaB\", \"asset_type\": \"ch\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"},\n        {\"name\": \"propA\", \"asset_type\": \"prop\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"},\n        {\"name\": \"bg\", \"asset_type\": \"bg\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"}\n    ],\n    \"post\": {\n    }\n}\n\n</code></pre>"},{"location":"usage/tips/#houdini-hython-override","title":"Houdini hython override","text":"<p>If the default Program Files lookup doesn\u2019t find Houdini\u2019s hython.exe, set an explicit path via the environment variable <code>PUZZLE_HYTHON_PATH</code>.</p> <ul> <li>Example (PowerShell): <code>$env:PUZZLE_HYTHON_PATH = 'C:/SideFX/Houdini 20.0.653/bin/hython.exe'</code></li> <li>Or use the DCC harness option <code>--program-directory</code> to point at the SideFX install root.</li> </ul>"}]}