{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Concept","text":"<p> Puzzle2 is a simple pipeline framework for Python scripts. The goal is to separate scripts from GUI and reuse them at any time, as well as to use the same scripts for batch processing. </p> <p> We have seen a lot of situations like this.</p> <p></p> <p>if we use this module.  we can do like this. and this is exactry what puzzle2 trying to do.</p> <p></p>"},{"location":"concept/","title":"Concept","text":"<p>test</p>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#requirement","title":"Requirement","text":"<p>python 2.7, 3.7+</p> <p></p>"},{"location":"installation/#how-to","title":"How To","text":"<p>You can clone from Github or install from pip</p> <pre><code>pip install git+https://github.com/hat27/puzzle2.git\n</code></pre>"},{"location":"installation/#required","title":"required","text":"<p>If you clone repo, we recommanded to running <code>pip install -r requirements.txt</code> or  look inside file and install by your self.</p>"},{"location":"batch/introduction/","title":"Introduction","text":"<p>PuzzleBatch is a powerful feature that is currently under development. Once we create a Puzzle configuration, we can execute it without opening any applications.</p> <p>The goal is to use the dispatcher system (like Deadline) to run any type of process via server.</p>"},{"location":"batch/sample/","title":"Sample","text":"<pre><code>import unittest\nimport os\nimport sys\nimport pprint\nimport datetime\n\nmodule_path = os.path.normpath(os.path.join(__file__, \"../../../\"))\nsys.path.insert(0, module_path)\n\npuzzle_directory = \"\"\nsys.path.insert(0, puzzle_directory)\n\nfrom puzzle2.PuzzleBatch import run_process\nimport puzzle2.pz_config as pz_config\nimport puzzle2.pz_env as pz_env\n\nclass BatchSample:\n    def test_all(self):\n        app_all = [\"mayapy\", \"rez\", \"mobupy\", \"motionbuilder\", \"maya\"] #, \"3dsmax\", \"3dsmaxpy\"] # [\"motionbuilder\"] #, \"mobupy\", \"motionbuilder\", \"maya\", \"mayapy\", \"rez\"] #, \"3dsmax\", \"3dsmaxpy\"\n        for app in app_all:\n            versions = [\"2020\"] #[\"2018\", \"2019\", \"2020\", \"2022\", \"2023\"]\n            for version in versions:\n                return_codes = self.execute_one(app, version, False)\n                if return_codes:\n                    # self.assertEqual(return_codes, [0, 0, 0])\n                    if return_codes == [0, 0, 0]:\n                        print(\"OK\")\n                    else:\n                        print(\"NG: {}\".format(return_codes))\n                else:\n                    print(\"job failed\")\n\ndef execute_one(self, app, version, file_mode=False):\n    # app: maya, mayapy, rez, motionbuilder, mobupy\n\n    command_data = {\"version\": version}\n\n    task_set = [{\"step\": \"pre\", \"tasks\": [{\"module\": \"tasks.win.open_file\"}]},\n                {\"step\": \"main\", \"tasks\": [{\"module\": \"tasks.win.export_file\"}]}]\n\n    data_set = {\"pre\": {\"open_path\": \"somewhere\"}, \n            \"main\": [{\"name\": \"nameA\"}, {\"name\": \"namessB\"}]}\n\n    command_data[\"sys_path\"] = \"sys path for ...\"\n    command_data[\"module_directory_path\"] = module_path\n    command_data[\"job_directory\"] = \"temp directory for job\"\n    if file_mode:\n        command_data[\"task_set_path\"] = \"task yml file\"\n        command_data[\"data_path\"] = \"data json file\"\n    else:\n        command_data[\"task_set\"] = task_set\n        command_data[\"data_set\"] = data_set\n\n    command_data[\"close_app\"] = True\n    if app == \"rez\":\n        command_data[\"launcher\"] = \"rez\"\n        command_data[\"rez_package\"] = \"projectA\"\n        command_data[\"rez_version\"] = \"1.0.0\"\n        command_data[\"app_package\"] = \"mayapy\"\n        app = \"mayapy\"\n\n    command, job_directory = run_process(app, **command_data)\n    result_path = \"{}/results.json\".format(job_directory)\n\n    print(\"result_path: {}\".format(result_path))\n    if command:\n        try:\n            info, data = pz_config.read(result_path)\n            print(\"data:\")\n            pprint.pprint(data)\n        except:\n            print(\"read failed\")\n            import traceback\n            traceback.print_exc()\n        return [l[\"return_code\"] for l in data]\n\n    return False\n\nif __name__ == \"__main__\":\n    x = BatchSample()\n    # x.test_all()\n    x.execute_one(\"mayapy\", \"2020\")\n</code></pre>"},{"location":"usage/config/","title":"Config","text":""},{"location":"usage/config/#config-options","title":"config options","text":"<p>to write each task config. we use key-value below.</p> key require type description name o str name of task module o str path to task comment - str data_key_replace - dict replace key name whitch used in data data_defaults - dict default value for specific key data_override - dict override value for specific key conditions - list condition for execute task break_on_exceptions - bool stop process when error occur"},{"location":"usage/config/#data_key_replace","title":"data_key_replace","text":"<p>eplace key name whitch used in data  </p> <p>config</p> <pre><code>data_key_replace:\n    min: start_frame\n    max: end_frame\n</code></pre> <p></p> <p>in this case, <code>start_frame</code> replaced to <code>min</code> and <code>end_frame</code> replaced to <code>max</code></p> <p></p> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\nconfig = [...]\ndata = {\n    \"start_frame\": 101,\n    \"end_frame\": 200\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n</code></pre> <p></p>"},{"location":"usage/config/#data_defaults","title":"data_defaults","text":"<p>set default values.if we set default values. we don't have to add key to data.</p> <p></p> <p>config</p> <pre><code>data_defaults:\n    min: 101\n</code></pre> <p>task</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))    \n\n</code></pre> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [...]\ndata = {\n    \"main\": {\n        \"max\": 200\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n# 101 - 200\n</code></pre> <p></p>"},{"location":"usage/config/#data_override","title":"data_override","text":"<p>if data_override exists, value will override to spesific value.</p> <p></p> <p>config</p> <pre><code>data_override:\n    min: 101\n</code></pre> <p>task</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))    \n\n</code></pre> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [...]\ndata = {\n    \"main\": {\n        \"min\": 0,\n        \"max\": 200\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n&gt;&gt; 101 - 200\n# min 0 was overrided by config\n</code></pre> <p></p>"},{"location":"usage/config/#conditions","title":"conditions","text":"<p>set conditions, then task will execute when condition passed</p> <p>config</p> <pre><code>conditions:\n    - change_frame_flag: false\n</code></pre> <p>task</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))    \n\n</code></pre> <p></p> <p>script</p> <pre><code># -*-coding: utf8-*-\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [...]\ndata = {\n    \"main\": {\n        \"min\": 0,\n        \"max\": 200,\n        \"change_frame_flag\": False\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n</code></pre> <p>in this case, this task will skipped. usually we use this when executing tasks from GUI.  </p>"},{"location":"usage/context/","title":"Context","text":"<p>context can access from everywhere</p> name description _app_ process app name _user_name_ PUZZLE_USERNAME or USERNAME _datetime_ datetime when process start _os_ version of os _python_version_ version of python"},{"location":"usage/context/#how-to-use-update_context","title":"How to Use update_context","text":"<p>use <code>data_key_replace</code> function to add <code>context.</code> to prefix before the value name. This way, the value will be searched from context.</p> <p>config</p> <pre><code>config = [\n  \"step\": \"main\",\n  \"tasks\": [\n      {\n        \"name\": \"set frame with offset\",\n        \"module\": \"somewhere.set_frame\"\n      },\n      {\n        \"name\": \"render\",\n        \"module\": \"somewhere.render\"\n        \"comment\": \"use new value from pre task\",\n        \"data_key_replace\":\n        {\n          \"start\": \"context.new_min\",\n          \"end\": \"context.new_max\"\n        }\n      }\n  ]\n]\n\n</code></pre> <p>set_frame.py</p> <pre><code>def main(event):\n    data = event[\"data\"]\n    update_context = {}\n\n    cmds.playbackOptions(min=data[\"min\"] - data[\"offset\"])\n    cmds.playbackOptions(max=data[\"max\"] + data[\"offset\"])\n\n    update_context[\"new_min\"] = data[\"min\"] - data[\"offset]\n    update_context[\"new_max\"] = data[\"max\"] + data[\"offset]\n\n    return {\"return_code\": 0, \"update_context\": update_context}\n</code></pre> <p>render.py</p> <pre><code>def main(event={}):\n    data = event.get(\"data\")\n    print(\"{} - {}\".format(data[\"start]))\n    render_file(data[\"start\"], data[\"end\"])\n    return {\"return_code\": 0}\n\n&gt;&gt; 201 - 300\n</code></pre>"},{"location":"usage/response/","title":"Response","text":"<p>return value will be <code>dict</code> or <code>None</code></p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    new_min = data[\"min\"] * 2\n    new_max = data[\"max] * 2\n    cmds.playbackOptions(min=new_min, max=new_max)\n    print(\"{} - {}\".format(new_min, new_max))\n\n    update_context = {\"min\": new_min, \"max\": new_max}\n    return {\"return_code\": 0, \"update_context\": update_context}\n</code></pre> key default type description return_code 0 int result for task process update_context {} dict update context break_on_conditions False bool if True, stop all process except closure step"},{"location":"usage/response/#return-code","title":"return code","text":"id results description 0 Success 1 Error 2 skipped 4 Import Error task was not found in sys.path 5 Key Error required key was not exists(optional)"},{"location":"usage/response/#update-context","title":"update context","text":"<p>add value to context</p>"},{"location":"usage/response/#sample-of-break-on-conditions","title":"sample of break on conditions","text":"<p>when start frame is lower then 0, stop the other tasks</p> <pre><code>def main(event):\n    if cmds.playbackOptions(min=True, q=True) &lt; 0:\n        return {\"return_code\": 0, \"break_on_conditions\": True}\n    return {\"return_code\": 0}\n</code></pre>"},{"location":"usage/rule/","title":"Rule","text":"<p>We must follow at least two rules to use this module.</p> <ol> <li>execute function name must be <code>main</code></li> <li>write order config</li> </ol> <p></p> <p>process image like this.</p> <p>we pick tasks and write it to order</p> <p></p> <p>task will imported so we need to add sys.path to them.</p> <p>root \u00a0\u00a0\u00a0\u00a0L somewhere \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L init.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task1.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task2.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task3.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0L task4.py  </p> <pre><code># -*-coding: utf8-*-\nimport sys\nroot = \"somewhere\"\nsys.path.append(root)\n\nfrom puzzle2.Puzzle import Puzzle\n\nconfig = [\n  \"step\": \"main\",\n  \"tasks\": [\n    {\"name\": \"task1\",\n     \"module\": \"somewhere.task1\"},\n    {\"name\": \"task2\",\n     \"module\": \"somewhere.task2\"},\n    {\"name\": \"task3\",\n     \"module\": \"somewhere.task3\"},\n    {\"name\": \"task4\",\n     \"module\": \"somewhere.task4\"},\n  ]\n]\n\npuzzle = Puzzle()\npuzzle.play(config)\n</code></pre>"},{"location":"usage/task/","title":"Task","text":"<p>We refer to each script as a <code>task</code>.</p> <p>we write before, task rule is use execute function name <code>main</code>.</p> <pre><code>def main():\n    print(\"hello puzzle2\")\n</code></pre> <p>this is the most easiest task. </p>"},{"location":"usage/task/#data","title":"data","text":"<p>for example, this task works to change scene to 101-200</p> <p></p> <p>change_frame.py</p> <pre><code>def main(event={}):\n    cmds.playbackOptions(min=101, max=200)\n    print(\"{} - {}\".format(101, 200))\n</code></pre> <p>In this scenario, we cannot reuse this task for other situations.  Therefore, we will need to give the minimum and maximum values from external data sources and make changes accordingly.</p> <p></p> <p>change_frame.py</p> <pre><code>def main(event={}):\n    data = event.get(\"data\", {})\n    cmds.playbackOptions(min=data[\"min\"], max=data[\"max\"])\n    print(\"{} - {}\".format(data[\"min], data[\"max\"]))\n</code></pre> <p>this looks more better.</p> <p></p> <p>script.py </p> <p>and then, this is usage for change_frame.py in puzzle process. CAUTION: we have to set data to same name as step name  </p> <pre><code># -*-coding: utf8-*-\nimport sys\nsys.path.append(root)\n\nfrom puzzle2.Puzzle import Puzzle\n\n# add to order config\nconfig = [\n  \"step\": \"main\",\n  \"tasks\": [\n    {\"name\": \"change_frame\",\n     \"module\": \"somewhere.change_frame\"}\n  ]\n]\n\n# set data to main step\ndata = {\n    \"main\": {\n        \"min\": 101, \n        \"max\": 200\n    }\n}\n\npuzzle = Puzzle()\npuzzle.play(config, data)\n\n# 101 - 200\n</code></pre>"},{"location":"usage/tips/","title":"Tips","text":""},{"location":"usage/tips/#use-yml-file","title":"use yml file","text":"<p>we usually use .yml file to write config. that will much easier to write it.</p> <p>yml file</p> <pre><code>info: {}\ndata:\n  some_tasks: \n    - step: pre\n      tasks:\n        - name: task1\n          module: somewhere.set_frame\n\n        - name: render\n          module: somewhere.render\n          comment: use new value from pre task\n          data_key_replace:\n            start: context.new_min\n            end: context.new_max\n\n</code></pre> <pre><code>info, config = pz_config.read(yml_path)\ndata = {}\n\npuzzle = Puzzle()\npuzzle.play(config[\"some_tasks\"], data)\n</code></pre>"},{"location":"usage/tips/#is-loop","title":"is loop?","text":"<p>In Puzzle system, whether tasks go through a loop or not depends on the data type. If the data type is a list, it will go through a loop. If the data type is a dictionary, it will only go through once.  </p> <p>A step refers to a sequential stage in your pipeline. It is simply a name you give to indicate what the tasks under that stage represent or achieve.</p> <p></p> <p>Looking at an example can help us understand better.</p> <p>config</p> <pre><code>  export_scene_tasks: \n    - step: pre\n      tasks:\n        - name: open file\n          module: somewhere.open_file\n\n        - name: export camera\n          module: somewhere.export_camera\n          conditions:\n            asset_type: camera\n\n    - step: main\n      comment: add export file info to context.\n      tasks:\n        - name: export ch assets\n          comment: append info to context\n          module: somewhere.export_ch\n          data_key_replace:\n            export_path: local_export_path\n\n          conditions:\n            asset_type: ch\n\n        - name: export prop assets\n          comment: append info to context\n          module: somewhere.export_prop\n          data_key_replace:\n            export_path: local_export_path          \n\n          conditions:\n            asset_type: prop\n\n        - name: export bg assets\n          comment: append info to context\n          module: somewhere.export_bg\n          data_key_replace:\n            export_path: local_export_path\n\n          conditions:\n            asset_type: bg\n\n        - name: copy to server\n          comment: copy export path to server\n          module: somewhere.copy_to\n          data_key_replace:\n            src_path: local_export_path\n            dst_path: server_export_path\n\n    - step: post\n      tasks:\n        - name: integrations to shotgrid\n          module: somewhere.send_to_sg\n          data_key_replace:\n            export_files: context.export_files\n</code></pre> <p>data</p> <pre><code>data = {\n    \"pre\": {\n        \"camera_name\": \"cam1\",\n        \"file\": \"xxxxx.ma\"\n    },\n    \"main\": [\n        {\"name\": \"charaA\", \"asset_type\": \"ch\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"},\n        {\"name\": \"charaB\", \"asset_type\": \"ch\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"},\n        {\"name\": \"propA\", \"asset_type\": \"prop\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"},\n        {\"name\": \"bg\", \"asset_type\": \"bg\", \"local_export_path\": \"local path\", \"server_export_path\": \"server\"}\n    ],\n    \"post\": {\n    }\n}\n\n</code></pre>"}]}